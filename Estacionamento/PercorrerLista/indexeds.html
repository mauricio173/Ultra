<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="css/index.css" />
  <script src="js/index.js" defer></script>

  <title>PercorrerLista</title>

  <style type="text/css" media="all"></style>
  <style>
   #abrir-popup:checked ~ #conteudo {
    display: block;
   }
   #fechar-popup:checked ~ #conteudo,
   #fechar-popup:checked ~ #fechar-popup-btn {
    display: none;
   }

   #abrir-popup-btn {
    display: block;
    color: white;
    background-color: #a45fd2;
    width: fit-content;
    padding: 12px 34px;
    border-radius: 4px;
    box-shadow: 0px 5px 15px -5px #20003044;
    cursor: pointer;
   }
   /*#fechar-popup-btn {
  background-color: #00000020;
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
}*/
   #fechar-popup-btn {
    background-color: #00000020;
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
   }

   #conteudo {
    box-sizing: border-box;
    position: fixed;
    width: min(380px, 90vw);
    height: 160px;
    /*
  left: max(calc(50vw - 380px / 2), 4vw);
  top: calc(50vh - 80px);
  */
    left: max(calc(50vw - 380px / 2), 4vw);
    top: calc(50vh - 250px);
    padding: 22px;
    background-color: #efd7ff;
    border: 2px solid #c59fde;
    border-radius: 8px;
    box-shadow: 0px 5px 15px -5px #0000003c;
    overflow: scroll;
   }
  </style>
 </head>
 <body>
  <span>
   <input id="abrir-popup" name="popup" type="radio" hidden />
   <input id="fechar-popup" name="popup" type="radio" hidden checked />

   <label id="abrir-popup-btn" for="abrir-popup" style="display: none">Abrir</label>

   <div id="conteudo">
    <label id="fechar-popup-btn" for="fechar-popup" hidden>Fechar</label>
    <p>Itens copiados com sucesso!</p>
   </div>
   <script type="text/javascript" charset="utf-8"></script>
  </span>
  <h1>Lista v2</h1>
  <header class="header">
   <img src="https://mauricio173.github.io/Ultra/img/logo-ultra.png" alt="Logotipo Academia Ultra" style="width: 80px; height: 50px" />
   <nav class="nav">
    <ul class="">
     <li><a href="https://mauricio173.github.io/Ultra" target="_blank"> Início </a></li>
     <li><a href="https://mauricio173.github.io/Ultra/Estacionamento/index.html" target="_blank"> GARAGEM </a></li>
     <li><a href="https://mauricio173.github.io/Ultra/Tarefas/index.html" target="_blank"> Tarefa </a></li>
     <li><a href="https://mauricio173.github.io/Ultra/Estacionamento/PercorrerLista/indexed.html" target="_blank"> Lista </a></li>
    </ul>
   </nav>
  </header>
  <h1 onclick="labelsValue(), percorre(), ajuste()" id="h1">PercorrerLista</h1>
  <textarea class="labelListas" name="" id="listasText" rows="8" cols="40" oninput="percorre(), ajuste(), vencimentos(), ajusteDataFim()"></textarea>

  <h3 class="h1">CPFS REPETIDOS:</h3>
  <div class="" id="viewLista"></div>

  <h3 class="h1" style="display: none !important">CPFS REPETIDOS:</h3>
  <label class="labelListas" id="viewListas" style="display: none !important"></label>
  <h3 class="h1">NOMES AJUSTADOS:</h3>
  <p class="invalido" id="invalido"></p>
  <label class="labelListas" id="viewAjustes"></label>
  <br />
  <h3 class="h1">CPFS VENCIDOS:</h3>
  <div class="" id="viewListaVencidos"></div>
  <br />
  <br />
  <h3 class="h1">DATAS AJUSTADAS:</h3>
  <p class="invalido" id="invalidos"></p>
  <label class="labelListas" id="viewAjustesData"></label>

  <footer class="footer"></footer>
  <!--
  02175203085;MAURICIO RIOS;2025-01-02;2025-03-02;1;02175203085
03312991196;MAURICIO RIOS;2025-01-02;2025-03-02;1;03312991196
93603835034;MAURICIO RIOS Holifield;2025-01-02;2025-03-02;1;93603835034
86569929020;MAURICIO RIOS ALBUQUERQUE;2025-01-02;2025-03-02;1;86569929020
00997902035;MAURICIO RIOS ramos;2025-01-02;2025-03-02;1;00997902035
01048137090;MAURICIO RIOS teche;2025-01-02;2025-03-02;1;01048137090
72779330015;MAURICIO marques RIOS;2025-01-02;2025-03-02;1;72779330015
    
    
  agora observe o seguinte registro:
  72779330015;MAURICIO marques RIOS;2025-01-02;2025-07-02;1;72779330015
  
  A primeira parte é o CPF 72779330015.
  A segunda parte é o nome completo MAURICIO marques RIOS.
  A terceira parte é a data inicial 2025-01-02.
  A quarta parte é a data final 2025-07-02.
  A quinta parte é o dígito verificador 1.
  A sexta e último parte é o CPF repetido.
  Preciso que em <div class="" id="viewListaVencidos"></div>
  Faça o mesmo que em percorre e em ajuste porém informando as datas finais proximas do vencimento. Considere o vencimento como faltando 4 meses para encerrar. Crie uma função chamada vencimentos que execute o requisito.
    
  -->
  <!--
   02175203085;MAURICIO RIOS;2025-01-02;2025-03-02;1;02175203085
03312991196;MAURICIO RIOS;2025-01-02;2025-03-02;1;03312991196
93603835034;MAURICIO RIOS Holifield;2025-01-02;2025-03-02;1;93603835034
86569929020;MAURICIO RIOS ALBUQUERQUE;2025-01-02;2025-03-02;1;86569929020
00997902035;MAURICIO RIOS ramos;2025-01-02;2025-03-02;1;00997902035
01048137090;MAURICIO RIOS teche;2025-01-02;2025-03-02;1;01048137090
72779330015;MAURICIO marques RIOS;2025-01-02;2025-03-02;1;72779330015
  -->
  <script type="text/javascript" charset="utf-8">
  /*
  function vencimentos() {
    const viewListaVencidos = document.getElementById("viewListaVencidos");
    const label = document.getElementById("listasText").value;

    viewListaVencidos.innerHTML = ``; // Limpar o conteúdo anterior

    const registros = label.split(/\r?\n/); // Dividir os registros por linha
    const hoje = new Date(); // Data atual

    const registrosVencendo = registros.filter(registro => {
        const partes = registro.split(";"); // Dividir o registro em partes
        if (partes.length < 6) return false; // Ignorar registros incompletos

        const dataFinal = new Date(partes[3]); // Obter a data final
        const diferencaMeses =
            (dataFinal.getFullYear() - hoje.getFullYear()) * 12 +
            (dataFinal.getMonth() - hoje.getMonth()); // Diferença em meses

        return diferencaMeses <= 4 && diferencaMeses >= 0; // Verificar vencimento
    });
console.log(registrosVencendo);
    if (registrosVencendo.length === 0) {
        viewListaVencidos.innerHTML = `<p>Nenhum registro próximo ao vencimento encontrado.</p>`;
        return;
    }

    registrosVencendo.forEach(registro => {
        const partes = registro.split(";");
        const cpf = partes[0];
        const nome = partes[1];
        const dataFinal = partes[3];
        const div = document.createElement("div");

        div.classList.add("registroVencendo");
        div.innerHTML = `
            <p><strong>CPF:</strong> ${cpf}</p>
            <p><strong>Nome:</strong> ${nome}</p>
            <p><strong>Data Final:</strong> ${dataFinal}</p>
        `;
    
        viewListaVencidos.appendChild(div);
    });
}


function vencimentos() {
    const viewListaVencidos = document.getElementById("viewListaVencidos");
    const label = document.getElementById("listasText").value;

    viewListaVencidos.innerHTML = ``; // Limpar o conteúdo anterior

    const registros = label.split(/\r?\n/); // Dividir os registros por linha
    const hoje = new Date(); // Data atual

    const registrosVencendo = registros.filter(registro => {
        const partes = registro.split(";"); // Dividir o registro em partes
        if (partes.length < 6) return false; // Ignorar registros incompletos

        const dataFinal = new Date(partes[3]); // Obter a data final
        const diferencaMeses =
            (dataFinal.getFullYear() - hoje.getFullYear()) * 12 +
            (dataFinal.getMonth() - hoje.getMonth()); // Diferença em meses

        return diferencaMeses <= 4 && diferencaMeses >= 0; // Verificar vencimento
    });

    if (registrosVencendo.length === 0) {
        viewListaVencidos.innerHTML = `<p>Nenhum registro próximo ao vencimento encontrado.</p>`;
        return;
    }

    registrosVencendo.forEach(registro => {
        const partes = registro.split(";");
        const cpf = partes[0];
        const nome = partes[1];
        const dataFinal = partes[3];
        const div = document.createElement("div");

        // Nova estrutura adicionada
        div.classList.add("cpfRepetidoRegistros");
        div.innerHTML = `
            <p>
                O CPF ${cpf} está próximo do vencimento.
            </p>
            <h4>Registro completo:</h4>
            <ul class="ulListas">
                <li><strong>CPF:</strong> ${cpf}</li>
                <li><strong>Nome:</strong> ${nome}</li>
                <li><strong>Data Final:</strong> ${dataFinal}</li>
            </ul>
        `;

        // Append na view
        viewListaVencidos.appendChild(div);
    });
}

function vencimentos() {
    const viewListaVencidos = document.getElementById("viewListaVencidos");
    const label = document.getElementById("listasText").value;

    viewListaVencidos.innerHTML = ``; // Limpar o conteúdo anterior

    const registros = label.split(/\r?\n/); // Dividir os registros por linha
    const hoje = new Date(); // Data atual

    const registrosVencendo = registros.filter(registro => {
        const partes = registro.split(";"); // Dividir o registro em partes
        if (partes.length < 6) return false; // Ignorar registros incompletos

        const dataFinal = new Date(partes[3]); // Obter a data final
        const diferencaMeses =
            (dataFinal.getFullYear() - hoje.getFullYear()) * 12 +
            (dataFinal.getMonth() - hoje.getMonth()); // Diferença em meses

        return diferencaMeses <= 4 && diferencaMeses >= 0; // Verificar vencimento
    });

    if (registrosVencendo.length === 0) {
        viewListaVencidos.innerHTML = `<p>Nenhum registro próximo ao vencimento encontrado.</p>`;
        return;
    }

    // Criar uma estrutura para listar todos os CPFs próximos ao vencimento
    const listaCPFs = registrosVencendo.map(registro => {
        const partes = registro.split(";");
        const cpf = partes[0];
        const dataFinal = partes[3];
        return `${cpf} com vencimento em ${dataFinal.split("-").reverse().join("/")}`;
    });

    const divResumo = document.createElement("div");
    divResumo.classList.add("cpfRepetidoRegistros");
    divResumo.innerHTML = `
        <h3>Registros Próximos ao Vencimento:</h3>
        <ul class="ulListas">
            ${listaCPFs.map(cpfInfo => `<li>${cpfInfo}</li>`).join("")}
        </ul>
    `;

    // Adicionar o resumo acima dos detalhes individuais
    viewListaVencidos.appendChild(divResumo);

    // Adicionar detalhes individuais
    registrosVencendo.forEach(registro => {
        const partes = registro.split(";");
        const cpf = partes[0];
        const nome = partes[1];
        const dataFinal = partes[3];
        const div = document.createElement("div");

        div.classList.add("cpfRepetidoRegistros");
        div.innerHTML = `
            <p>
                O CPF ${cpf} está próximo do vencimento.
            </p>
            <h4>Registro completo:</h4>
            <ul class="ulListas">
                <li><strong>CPF:</strong> ${cpf}</li>
                <li><strong>Nome:</strong> ${nome}</li>
                <li><strong>Data Final:</strong> ${dataFinal}</li>
            </ul>
        `;

        viewListaVencidos.appendChild(div);
    });
}

*/


/*
function vencimentos() {
    const label = document.getElementById("listasText").value; // Obter o texto do campo
    const viewListaVencidos = document.getElementById("viewListaVencidos"); // Elemento onde o resultado será exibido
    viewListaVencidos.innerHTML = ``; // Limpar o conteúdo anterior

    // Separar os registros por quebra de linha
    const registros = label.split(/\r?\n/);

    const hoje = new Date(); // Data atual
    const proximidade = 4; // Meses de proximidade
    const cpfsProcessados = new Set(); // Set para rastrear CPFs já exibidos

    // Função para normalizar nomes (letras maiúsculas e sem acentuações)
    const normalizarNome = nome => nome
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .toUpperCase();

    // Filtrar registros próximos do vencimento
    const registrosVencidos = registros.filter(registro => {
        const partes = registro.split(";");

        if (partes.length >= 4) {
            const dataFinal = new Date(partes[3]); // Obter a data final
            const diffMeses = (dataFinal.getFullYear() - hoje.getFullYear()) * 12 + (dataFinal.getMonth() - hoje.getMonth());

            return diffMeses <= proximidade && diffMeses >= 0; // Próximo do vencimento
        }

        return false;
    });

    // Agrupar por CPF
    const registrosPorCPF = registrosVencidos.reduce((acc, registro) => {
        const partes = registro.split(";");
        const cpf = partes[0];
        partes[1] = normalizarNome(partes[1]); // Normalizar nome completo

        if (!acc[cpf]) acc[cpf] = [];
        acc[cpf].push(partes.join(";")); // Atualizar o registro ajustado

        return acc;
    }, {});

    // Exibir lista de CPFs próximos do vencimento
    const spanDetalhes = document.createElement("div");
    spanDetalhes.classList.add("cpfRepetidoRegistros");
    spanDetalhes.innerHTML = `
        <h3>CPFs Próximos do Vencimento:</h3>
        <ul class="ulListas">
            ${Object.keys(registrosPorCPF)
                .filter(cpf => !cpfsProcessados.has(cpf)) // Garantir que o CPF ainda não foi processado
                .map(cpf => {
                    cpfsProcessados.add(cpf); // Marcar o CPF como processado
                    return `<li>${cpf} encontrado ${registrosPorCPF[cpf].length} ${registrosPorCPF[cpf].length > 1 ? "vezes" : "vez"}.</li>`;
                })
                .join("")}
        </ul>
    `;
    viewListaVencidos.prepend(spanDetalhes);

    // Exibir registros completos para cada CPF
    Object.keys(registrosPorCPF).forEach(cpf => {
        const div = document.createElement("div");
        div.classList.add("cpfRepetidoRegistros");
        div.innerHTML = `
            <p>
                O CPF ${cpf} está próximo do vencimento em ${registrosPorCPF[cpf].length} ${registrosPorCPF[cpf].length > 1 ? "registros" : "registro"}.
            </p>
            <h4>Registros completos:</h4>
            <ul class="ulListas">
                ${registrosPorCPF[cpf].map(registro => `<li>${registro}</li>`).join("")}
            </ul>
        `;
        viewListaVencidos.appendChild(div);
    });
}

function ajusteDataFim() {
    const label = document.getElementById("listasText").value; // Obter o texto do campo
    const viewAjustesData = document.getElementById("viewAjustesData"); // Elemento onde o resultado será exibido
    const invalidos = document.getElementById("invalidos"); // Mensagem para exibir possíveis erros
    viewAjustesData.innerHTML = ``; // Limpar o conteúdo anterior
    invalidos.innerHTML = ``;

    const hoje = new Date(); // Data atual
    const dataFinal = new Date(); // Data final
    dataFinal.setMonth(dataFinal.getMonth() + 6); // Adicionar 6 meses à data atual

    // Separar os registros por quebra de linha
    const registros = label.split(/\r?\n/);

    const registrosAjustados = registros.map(registro => {
        const partes = registro.split(";");

        if (partes.length < 4) {
            invalidos.innerHTML += `<p>Registro inválido ou incompleto: ${registro}</p>`;
            return registro; // Retornar registro sem alteração
        }

        try {
            // Processar o nome
            const nomeCompleto = partes[1].normalize("NFD").replace(/[\u0300-\u036f]/g, ""); // Remover acentos
            const nomes = nomeCompleto.split(" ");
            const primeiroNome = nomes[0].toUpperCase();
            const ultimoSobrenome = nomes[nomes.length - 1].toUpperCase();
            const nomeAjustado = `${primeiroNome} ${ultimoSobrenome}`;

            // Atualizar as partes do registro
            partes[1] = nomeAjustado; // Nome ajustado
            partes[2] = hoje.toISOString().split("T")[0]; // Data inicial (hoje)
            partes[3] = dataFinal.toISOString().split("T")[0]; // Nova data final (6 meses a partir de hoje)

            return partes.join(";");
        } catch (error) {
            invalidos.innerHTML += `<p>Erro ao ajustar registro: ${registro}</p>`;
            return registro; // Retornar registro sem alteração
        }
    });

    // Atualizar o innerHTML com os registros ajustados, cada um em uma linha
    viewAjustesData.innerHTML = registrosAjustados.join("<br>");

    const textoCompleto = registrosAjustados.join("\n");

    // Evento para copiar o texto ajustado ao clicar
    viewAjustesData.addEventListener("click", () => {
        navigator.clipboard
            .writeText(textoCompleto)
            .then(() => {
            	//console.log(textoCompleto);
                invalidos.innerHTML = `<p class="invalido">Itens ajustados copiados com sucesso!</p>`;
                setTimeout(() => (invalidos.innerHTML = ``), 3500);
            })
            .catch(err => {
                console.error("Erro ao copiar texto: ", err);
                invalidos.innerHTML = `<p class="invalido">Erro ao copiar texto!</p>`;
            });
    });
}

*/
function vencimentos() {
    const label = document.getElementById("listasText").value; // Obter o texto do campo
    const viewListaVencidos = document.getElementById("viewListaVencidos"); // Elemento onde o resultado será exibido
    viewListaVencidos.innerHTML = ``; // Limpar o conteúdo anterior

    // Separar os registros por quebra de linha
    const registros = label.split(/\r?\n/);

    const hoje = new Date(); // Data atual
    const proximidade = 4; // Meses de proximidade
    const cpfsProcessados = new Set(); // Set para rastrear CPFs já exibidos

    // Função para normalizar nomes (letras maiúsculas e sem acentuações)
    const normalizarNome = nome => nome
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .toUpperCase();

    // Filtrar registros próximos do vencimento
    const registrosVencidos = registros.filter(registro => {
        const partes = registro.split(";");

        if (partes.length >= 4) {
            const dataFinal = new Date(partes[3]); // Obter a data final
            const diffMeses = (dataFinal.getFullYear() - hoje.getFullYear()) * 12 + (dataFinal.getMonth() - hoje.getMonth());

            return diffMeses <= proximidade && diffMeses >= 0; // Próximo do vencimento
        }

        return false;
    });

    // Agrupar por CPF
    const registrosPorCPF = registrosVencidos.reduce((acc, registro) => {
        const partes = registro.split(";");
        const cpf = partes[0];
        partes[1] = normalizarNome(partes[1]); // Normalizar nome completo

        if (!acc[cpf]) acc[cpf] = [];
        acc[cpf].push(partes.join(";")); // Atualizar o registro ajustado

        return acc;
    }, {});

    // Exibir lista de CPFs próximos do vencimento
    const spanDetalhes = document.createElement("div");
    spanDetalhes.classList.add("cpfRepetidoRegistros");
    spanDetalhes.innerHTML = `
        <h3>CPFs Próximos do Vencimento:</h3>
        <ul class="ulListas">
            ${Object.keys(registrosPorCPF)
                .filter(cpf => !cpfsProcessados.has(cpf)) // Garantir que o CPF ainda não foi processado
                .map(cpf => {
                    cpfsProcessados.add(cpf); // Marcar o CPF como processado
                    return `<li>${cpf} encontrado ${registrosPorCPF[cpf].length} ${registrosPorCPF[cpf].length > 1 ? "vezes" : "vez"}.</li>`;
                })
                .join("")}
        </ul>
    `;
    viewListaVencidos.prepend(spanDetalhes);

    // Exibir registros completos para cada CPF
    Object.keys(registrosPorCPF).forEach(cpf => {
        const div = document.createElement("div");
        div.classList.add("cpfRepetidoRegistros");
        div.innerHTML = `
            <p>
                O CPF ${cpf} está próximo do vencimento em ${registrosPorCPF[cpf].length} ${registrosPorCPF[cpf].length > 1 ? "registros" : "registro"}.
            </p>
            <h4>Registros completos:</h4>
            <ul class="ulListas">
                ${registrosPorCPF[cpf].map(registro => `<li>${registro}</li>`).join("")}
            </ul>
        `;
        viewListaVencidos.appendChild(div);
    });
}

function ajusteDataFim() {
    const label = document.getElementById("listasText").value; // Obter o texto do campo
    const viewAjustesData = document.getElementById("viewAjustesData"); // Elemento onde o resultado será exibido
    const invalidos = document.getElementById("invalidos"); // Mensagem para exibir possíveis erros
    viewAjustesData.innerHTML = ``; // Limpar o conteúdo anterior
    invalidos.innerHTML = ``;

    const hoje = new Date(); // Data atual
    const dataFinal = new Date(); // Data final
    dataFinal.setMonth(dataFinal.getMonth() + 6); // Adicionar 6 meses à data atual

    // Separar os registros por quebra de linha
    const registros = label.split(/\r?\n/);

    // Usando um Set para evitar duplicação de registros
    const cpfsProcessados = new Set();

    const registrosAjustados = registros.map(registro => {
        const partes = registro.split(";");

        if (partes.length < 4) {
            invalidos.innerHTML += `<p>Registro inválido ou incompleto: ${registro}</p>`;
            return registro; // Retornar registro sem alteração
        }

        try {
            // Processar o nome
            const nomeCompleto = partes[1].normalize("NFD").replace(/[\u0300-\u036f]/g, ""); // Remover acentos
            const nomes = nomeCompleto.split(" ");
            const primeiroNome = nomes[0].toUpperCase();
            const ultimoSobrenome = nomes[nomes.length - 1].toUpperCase();
            const nomeAjustado = `${primeiroNome} ${ultimoSobrenome}`;

            // Atualizar as partes do registro
            partes[1] = nomeAjustado; // Nome ajustado
            partes[2] = hoje.toISOString().split("T")[0]; // Data inicial (hoje)
            partes[3] = dataFinal.toISOString().split("T")[0]; // Nova data final (6 meses a partir de hoje)

            if (!cpfsProcessados.has(partes[0])) {
                cpfsProcessados.add(partes[0]); // Marcar CPF como processado
                return partes.join(";");
            }

            return ""; // Ignorar registros repetidos
        } catch (error) {
            invalidos.innerHTML += `<p>Erro ao ajustar registro: ${registro}</p>`;
            return registro; // Retornar registro sem alteração
        }
    }).filter(registro => registro !== ""); // Filtrar registros vazios (repetidos)

    // Atualizar o innerHTML com os registros ajustados, cada um em uma linha
    viewAjustesData.innerHTML = registrosAjustados.join("<br>");

    const textoCompleto = registrosAjustados.join("\n");

    // Evento para copiar o texto ajustado ao clicar
    viewAjustesData.addEventListener("click", () => {
        navigator.clipboard
            .writeText(textoCompleto)
            .then(() => {
                invalidos.innerHTML = `<p class="invalido">Itens ajustados copiados com sucesso!</p>`;
                setTimeout(() => (invalidos.innerHTML = ``), 3500);
            })
            .catch(err => {
                console.error("Erro ao copiar texto: ", err);
                invalidos.innerHTML = `<p class="invalido">Erro ao copiar texto!</p>`;
            });
    });
}

function percorre() {
    const viewListas = document.querySelector("#viewLista");
    viewListas.innerHTML = ``;

    // Obter o conteúdo do elemento <label>
    const label = document.getElementById("listasText").value;
    // Expressão regular para encontrar CPFs (sequências de 11 dígitos)
    const regexCPF = /\b\d{11}\b/g;

    // Extrair CPFs do texto
    const cpfs = label.match(regexCPF);

    // Criar um mapa para contar as ocorrências
    const cpfCounts = cpfs.reduce((acc, cpf) => {
        acc[cpf] = (acc[cpf] || 0) + 1;
        return acc;
    }, {});

    // Separar os CPFs repetidos (mais de 2 ocorrências)
    const repeatedCPFs = Object.keys(cpfCounts).filter(cpf => cpfCounts[cpf] > 2);

    // Dividir o texto original em registros com base em quebras (supondo registros separados por espaço ou quebra de linha)
    const registros = label.split(/(?<=\d{11})\s+/);

    // Identificar os registros completos que contêm CPFs repetidos
    const registrosRepetidos = registros.filter(registro => repeatedCPFs.some(cpf => registro.includes(cpf)));

    // Verificar se há CPFs repetidos
    if (repeatedCPFs.length === 0) {
        console.log("Nenhum CPF repetido encontrado.");
    }

    // Exibir a quantidade de vezes que cada CPF repetido foi encontrado
    repeatedCPFs.forEach(cpf => {
        // Filtrar os registros para o CPF atual
        const registrosDoCpf = registrosRepetidos.filter(registro => registro.includes(cpf));
        
        const div = document.createElement("div");
        div.classList.add("cpfRepetidoRegistros");
        div.innerHTML = `
        <p>
        O CPF ${cpf} foi encontrado em ${registrosDoCpf.length} ${registrosDoCpf.length > 1 ? "registros" : "registro"}.
        </p>
        <ul class="ulListas">
            ${registrosDoCpf.map(registro => `<li>${registro}</li>`).join("")}
        </ul>
    `;
        viewListas.appendChild(div);
    });
}

// Função para ajustar os registros, evitando duplicação de CPF
const ajustarRegistros = (registros) => {
    const cpfsProcessados = new Set(); // Para rastrear CPFs já processados
    return registros.map(registro => {
        const partes = registro.split(";");
        if (partes.length > 1) {
            const cpf = partes[0];
            
            // Verifica se o CPF já foi processado para evitar duplicação
            if (cpfsProcessados.has(cpf)) {
                return ""; // Retorna uma string vazia para ignorar registros duplicados
            }
            cpfsProcessados.add(cpf); // Marca o CPF como processado

            partes[1] = obterPrimeiroEUltimoNome(partes[1]);
        }
        return partes.join(";");
    }).filter(registro => registro !== ""); // Filtra os registros vazios (duplicados)
};

// Função para obter o primeiro e o último nome, considerando as partículas
const obterPrimeiroEUltimoNome = (nomeCompleto) => {
    const ignorarParticulas = ["da", "de", "do", "das", "dos", "e", "a", "o"];
    const nomes = nomeCompleto.trim().split(" ");
    const primeiroNome = nomes[0];
    let ultimoSobrenome = nomes[nomes.length - 1];

    // Verifica se o último sobrenome é uma partícula e ajusta
    if (ignorarParticulas.includes(ultimoSobrenome.toLowerCase()) && nomes.length > 1) {
        ultimoSobrenome = nomes[nomes.length - 2];
    }

    return `${primeiroNome.toUpperCase()} ${ultimoSobrenome.toUpperCase()}`;
};

// Função para atualizar a visualização no DOM
const atualizarView = (elemento, registrosAjustados) => {
    elemento.innerHTML = registrosAjustados.join("<br>");
};

// Função para copiar registros para a área de transferência
const copiarRegistros = (textoCompleto, abrirPopup, fecharPopup, invalido, conteudoTexto) => {
    navigator.clipboard.writeText(textoCompleto.split("<br>").join("\n"))
        .then(() => {
            invalido.innerHTML = "Itens copiados com sucesso!";
            abrirPopup.click();
            conteudoTexto.innerHTML = textoCompleto.split("<br>").join("\n");
            setTimeout(() => {
                invalido.style.visibility = "hidden";
                fecharPopup.click();
            }, 3500);
        })
        .catch(err => {
            console.error("Erro ao copiar texto: ", err);
        });
};

// Função principal
function ajuste() {
    const label = document.getElementById("listasText").value;
    const viewAjustes = document.getElementById("viewAjustes");

    viewAjustes.innerHTML = ``;

    const registros = label.split(/\r?\n/);
    const registrosAjustados = ajustarRegistros(registros);

    atualizarView(viewAjustes, registrosAjustados);

    const textoCompleto = registrosAjustados.join("<br>");
    viewAjustes.addEventListener("click", () => {
        const abrir = document.querySelector("#abrir-popup-btn");
        const fechar = document.querySelector("#fechar-popup-btn");
        const invalido = document.querySelector("#invalido");
        const conteudo = document.querySelector("#conteudo");
        const conteudoTexto = conteudo.querySelector("p");

        copiarRegistros(textoCompleto, abrir, fechar, invalido, conteudoTexto);
    });
}



  function percorrer() {
    const viewListas = document.querySelector("#viewLista");
    viewListas.innerHTML = ``;

    // Obter o conteúdo do elemento <label>
    const label = document.getElementById("listasText").value;
    // Expressão regular para encontrar CPFs (sequências de 11 dígitos)
    const regexCPF = /\b\d{11}\b/g;

    // Extrair CPFs do texto
    const cpfs = label.match(regexCPF);

    // Criar um mapa para contar as ocorrências
    const cpfCounts = cpfs.reduce((acc, cpf) => {
     acc[cpf] = (acc[cpf] || 0) + 1;
     return acc;
    }, {});

    // Separar os CPFs repetidos (mais de 2 ocorrências)
    const repeatedCPFs = Object.keys(cpfCounts).filter(cpf => cpfCounts[cpf] > 2);

    // Dividir o texto original em registros com base em quebras (supondo registros separados por espaço ou quebra de linha)
    const registros = label.split(/(?<=\d{11})\s+/);

    // Identificar os registros completos que contêm CPFs repetidos
    const registrosRepetidos = registros.filter(registro => repeatedCPFs.some(cpf => registro.includes(cpf)));

    // Verificar se há CPFs repetidos
    if (repeatedCPFs.length === 0) {
     console.log("Nenhum CPF repetido encontrado.");
    }

    //console.log(repeatedCPFs);

    // Exibir a quantidade de vezes que cada CPF repetido foi encontrado
    repeatedCPFs.forEach(cpf => {
     // Filtrar os registros para o CPF atual
     const registrosDoCpf = registrosRepetidos.filter(registro => registro.includes(cpf));
    // console.log(`O CPF ${cpf} foi encontrado em ${cpfCounts[cpf] / 2} registros.`);

     // const p = document.createElement("span");
     /*
     <div class="cpfRepetidoRegistros">
    <p>
    O CPF ${cpf} foi encontrado em ${cpfCounts[cpf] / 2} registros.
    </p>
    <p>
     CPF: <br/> 
     ${cpf}
    </p>
    <h4>Registros completos:</h4>
    <ul class="ulListas">
      ${registrosDoCpf.map(registro => `<li style="margin: 6px;">${registro}</li>`).join("")}
    </ul>
   </div>
     */
     const div = document.createElement("div");
     div.classList.add("cpfRepetidoRegistros");
     div.innerHTML = `
    <p>
    O CPF ${cpf} foi encontrado em ${cpfCounts[cpf] / 2} registros.
    </p>
   
    <h4>Registros completos:</h4>
    <ul class="ulListas">
      ${registrosDoCpf.map(registro => `<li>${registro}</li>`).join("")}
    </ul>
    `;
     viewListas.appendChild(div);
    });

    /*
    <div class="cpfRepetido">
    <h3>CPF Repetidos:</h3>
    <ul class="ulListas">
     ${repeatedCPFs.map(cpf => `<li>${cpf}</li>`).join("")}
    </ul>
   </div>
    */

    // Adicionar um <span> contendo todos os CPFs repetidos
    const spanCPFsRepetidos = document.createElement("div");

    spanCPFsRepetidos.classList.add("cpfRepetido");
    spanCPFsRepetidos.innerHTML = `
    <h3>CPF Repetidos:</h3>
    <ul class="ulListas">
     ${repeatedCPFs
      .map(
       cpf => `<li>${cpf} encontrado ${cpfCounts[cpf] / 2} vezes.
     </li>`
      )
      .join("")}
    </ul>
  `;
    viewListas.prepend(spanCPFsRepetidos);
   }
   
   
   
  	const ignorarParticula = ["da", "de", "do", "das", "dos", "e", "a", "o"];

// Função para ajustar os registros
const ajustarRegistro = registros => {
    return registros.map(registro => {
        const partes = registro.split(";");
        if (partes.length > 1) {
            partes[1] = obterPrimeiroEUltimoNome(partes[1]);
        }
        return partes.join(";");
    });
};

// Função para obter o primeiro e último nome
const obterPrimeiroEUltimoNomes = nomeCompleto => {
    const ignorarParticulas = ["da", "de", "do", "das", "dos", "e", "a", "o"];
    const nomes = nomeCompleto.trim().split(" ");
    const primeiroNome = nomes[0];
    let ultimoSobrenome = nomes[nomes.length - 1];

    if (ignorarParticulas.includes(ultimoSobrenome.toLowerCase()) && nomes.length > 1) {
        ultimoSobrenome = nomes[nomes.length - 2];
    }

    return `${primeiroNome.toUpperCase()} ${ultimoSobrenome.toUpperCase()}`;
};

// Função para atualizar a visualização no DOM
const atualizarViews = (elemento, registrosAjustados) => {
    elemento.innerHTML = registrosAjustados.join("<br>");
};

// Função para copiar registros para a área de transferência
const copiarRegistro = (textoCompleto, abrirPopup, fecharPopup, invalido, conteudoTexto) => {
    navigator.clipboard.writeText(textoCompleto.split("<br>").join("\n"))
        .then(() => {
            invalido.innerHTML = "Itens copiados com sucesso!";
            abrirPopup.click();
            conteudoTexto.innerHTML = textoCompleto.split("<br>").join("\n");
            setTimeout(() => {
                invalido.style.visibility = "hidden";
                fecharPopup.click();
            }, 3500);
        })
        .catch(err => {
            console.error("Erro ao copiar texto: ", err);
        });
};

// Função principal
function ajustes() {
    const label = document.getElementById("listasText").value;
    const viewAjustes = document.getElementById("viewAjustes");

    viewAjustes.innerHTML = ``;

    const registros = label.split(/\r?\n/);
    const registrosAjustados = ajustarRegistros(registros);

    atualizarView(viewAjustes, registrosAjustados);

    const textoCompleto = registrosAjustados.join("<br>");
    viewAjustes.addEventListener("click", () => {
        const abrir = document.querySelector("#abrir-popup-btn");
        const fechar = document.querySelector("#fechar-popup-btn");
        const invalido = document.querySelector("#invalido");
        const conteudo = document.querySelector("#conteudo");
        const conteudoTexto = conteudo.querySelector("p");

        copiarRegistros(textoCompleto, abrir, fechar, invalido, conteudoTexto);
    });
}


  </script>

  <script type="text/javascript" charset="utf-8">
   function percorrer() {
    const viewListas = document.querySelector("#viewLista");
    viewListas.innerHTML = ``;

    // Obter o conteúdo do elemento <label>
    const label = document.getElementById("listasText").value;
    // Expressão regular para encontrar CPFs (sequências de 11 dígitos)
    const regexCPF = /\b\d{11}\b/g;

    // Extrair CPFs do texto
    const cpfs = label.match(regexCPF);

    // Criar um mapa para contar as ocorrências
    const cpfCounts = cpfs.reduce((acc, cpf) => {
     acc[cpf] = (acc[cpf] || 0) + 1;
     return acc;
    }, {});

    // Separar os CPFs repetidos (mais de 2 ocorrências)
    const repeatedCPFs = Object.keys(cpfCounts).filter(cpf => cpfCounts[cpf] > 2);

    // Dividir o texto original em registros com base em quebras (supondo registros separados por espaço ou quebra de linha)
    const registros = label.split(/(?<=\d{11})\s+/);

    // Identificar os registros completos que contêm CPFs repetidos
    const registrosRepetidos = registros.filter(registro => repeatedCPFs.some(cpf => registro.includes(cpf)));

    // Verificar se há CPFs repetidos
    if (repeatedCPFs.length === 0) {
     console.log("Nenhum CPF repetido encontrado.");
    }

    //console.log(repeatedCPFs);

    // Exibir a quantidade de vezes que cada CPF repetido foi encontrado
    repeatedCPFs.forEach(cpf => {
     // Filtrar os registros para o CPF atual
     const registrosDoCpf = registrosRepetidos.filter(registro => registro.includes(cpf));
     console.log(`O CPF ${cpf} foi encontrado em ${cpfCounts[cpf] / 2} registros.`);

     // const p = document.createElement("span");
     /*
     <div class="cpfRepetidoRegistros">
    <p>
    O CPF ${cpf} foi encontrado em ${cpfCounts[cpf] / 2} registros.
    </p>
    <p>
     CPF: <br/> 
     ${cpf}
    </p>
    <h4>Registros completos:</h4>
    <ul class="ulListas">
      ${registrosDoCpf.map(registro => `<li style="margin: 6px;">${registro}</li>`).join("")}
    </ul>
   </div>
     */
     const div = document.createElement("div");
     div.classList.add("cpfRepetidoRegistros");
     /*
     div.innerHTML = `
      <p class="">
      O CPF ${cpf} foi encontrado em ${cpfCounts[cpf] / 2} registros.
      </p>
      <p class="">
      CPF: <br/> ${cpf}
      </p>
      <p class="">
      Registros completos:
      </p>
      <ul class="ul">
        ${registrosDoCpf.map(registro => `<li style="margin: 6px;">${registro}</li>`).join("")}
      </ul>
    `;
    */
     div.innerHTML = `
    <p>
    O CPF ${cpf} foi encontrado em ${cpfCounts[cpf] / 2} registros.
    </p>
   <!-- 
   <p>
     CPF: <br/> 
     ${cpf}
    </p>
    -->
    <h4>Registros completos:</h4>
    <ul class="ulListas">
      ${registrosDoCpf.map(registro => `<li>${registro}</li>`).join("")}
    </ul>
    `;
     viewListas.appendChild(div);
    });

    /*
    <div class="cpfRepetido">
    <h3>CPF Repetidos:</h3>
    <ul class="ulListas">
     ${repeatedCPFs.map(cpf => `<li>${cpf}</li>`).join("")}
    </ul>
   </div>
    */

    // Adicionar um <span> contendo todos os CPFs repetidos
    const spanCPFsRepetidos = document.createElement("div");

    spanCPFsRepetidos.classList.add("cpfRepetido");
    spanCPFsRepetidos.innerHTML = `
    <h3>CPF Repetidos:</h3>
    <ul class="ulListas">
     ${repeatedCPFs
      .map(
       cpf => `<li>${cpf} encontrado ${cpfCounts[cpf] / 2} vezes.
     </li>`
      )
      .join("")}
    </ul>
  `;
    viewListas.prepend(spanCPFsRepetidos);
   }

   function ajustes() {
    const label = document.getElementById("listasText").value; // Obter o texto da variável label
    const viewAjustes = document.getElementById("viewAjustes"); // Elemento onde o resultado será exibido
    viewAjustes.innerHTML = ``; // Limpar o conteúdo anterior

    // Separar os registros por quebra de linha
    const registros = label.split(/\r?\n/);

    // Processar cada registro
    const registrosAjustados = registros.map(registro => {
     // Dividir o registro em partes usando o delimitador ';'
     const partes = registro.split(";");

     if (partes.length > 1) {
      // Obter o nome completo (segunda parte do registro)
      const nomeCompleto = partes[1].trim();

      // Dividir o nome completo em palavras
      const nomes = nomeCompleto.split(" ");

      // Obter o primeiro nome e o último sobrenome
      const primeiroNome = nomes[0];
      const ultimoSobrenome = nomes[nomes.length - 1];

      // Atualizar a segunda parte do registro com o formato ajustado
      partes[1] = `${primeiroNome.toUpperCase()} ${ultimoSobrenome.toUpperCase()}`;
     }

     // Reconstruir o registro ajustado
     return partes.join(";");
    });
    // Atualizar o innerHTML com os registros ajustados, cada um em uma linha
    viewAjustes.innerHTML = registrosAjustados.join("<br>");

    const textoCompleto = registrosAjustados.join("<br>");

    viewAjustes.addEventListener("click", () => {
     const abrir = document.querySelector("#abrir-popup-btn");
     const fechar = document.querySelector("#fechar-popup-btn");
     const invalido = document.querySelector("#invalido");
     const conteudo = document.querySelector("#conteudo");
     const conteudoTexto = conteudo.querySelector("p");
     navigator.clipboard
      .writeText(textoCompleto.split("<br>").join(`\n`))
      .then(() => {
       // console.log(textoCompleto.split("<br>").join(`\n`));
       // invalido.style = "visibility: visible; font-size: 10px; color: #28abab";
       invalido.innerHTML = "Itens copiados com sucesso!";
       abrir.click();
       //console.log(textoCompleto.split("<br>"));
       conteudoTexto.innerHTML = `
${textoCompleto.split("<br>").join(`\n`)}
`;
       setTimeout(function () {
        invalido.style = "visibility: hidden";
        fechar.click();
       }, 3500);
      })
      .catch(err => {
       console.error("Erro ao copiar texto: ", err);
      });
     // console.log(textoCompleto.split("<br>"));
    });
   }

   function labelsValue() {
    const labels = document.getElementById("listasText");
    labels.value = `29044797832;ANDRE RYSEVAS BABBO;2024-09-20;2025-03-20;1;29044797832
26435681848;ITALO DIMARZIO;2024-09-20;2025-03-20;1;26435681848
05107842089;ANDRIELLY DE AVILA SILVEIRA;2024-09-20;2025-03-20;1;05107842089
86059092004;HAMID PUREZA;2024-09-20;2025-03-20;1;86059092004
86088777087;ANA VICTORIA DAVILA CAMARGO;2024-09-20;2025-03-20;1;86088777087
03545001040;LEONARDO SANTOS DA SILVA;2024-09-20;2025-03-20;1;03545001040
00428687008;KIM SAMUEL TAVARES;2024-09-20;2025-03-20;1;00428687008
03379443000;WAGNER LUIZ NUNES PADILHA;2024-09-20;2025-03-20;1;03379443000
02669395031;ANDRESSA GRASIELI BRAGA DOS SANTOS;2024-09-20;2025-03-20;1;02669395031
07904395495;REBECA BLEHM;2024-09-20;2025-03-20;1;07904395495
86463110078;MICAELLA DE BOER;2024-09-20;2025-03-20;1;86463110078
86320455020;VITORIA LUCHINI LAMM;2024-09-20;2025-03-20;1;86320455020
02832630081;GABRIEL HENZE BREGONZI;2024-09-20;2025-03-20;1;02832630081
02119074054;VANESSA DURANTI DA SILVA;2024-09-20;2025-03-20;1;02119074054
01603372083;CHRISTOPHER MACEDO LUIZ;2024-09-20;2025-03-20;1;01603372083
97360309034;DANIEL MOREIRA COELHO;2024-09-20;2025-03-20;1;97360309034
86842277000;ANDRIELLE FISCHER;2024-09-20;2025-03-20;1;86842277000
01010327062;ISABELLA NOSCHANG MITTELSTAEDT;2024-09-20;2025-03-20;1;01010327062
00954927044;NATHALIA NOSCHANG MITTELSTAEDT;2024-09-20;2025-03-20;1;00954927044
48335312087;ANA BEATRIZ NOSCHANG MITTELSTAEDT;2024-09-20;2025-03-20;1;48335312087
01336368012;MARCELA DIAS;2024-09-20;2025-03-20;1;01336368012
02221404025;GIULIA CARINA KRONBAUER RAICHLE;2024-09-20;2025-03-20;1;02221404025
71008390097;INGLIA LOPES;2024-09-20;2025-03-20;1;71008390097
00382173090;FABIANA NETTO RIBEIRO;2024-09-20;2025-03-20;1;00382173090
04502757012;LUISA BURTET MARTINS;2024-09-20;2025-03-20;1;04502757012
68402082068;DELCA BURTET MARTINS;2024-09-20;2025-03-20;1;68402082068
89888790072;FERNANDA MEDEIROS LOPES;2024-09-20;2025-03-20;1;89888790072
00005298008;ALINE RIBEIRO DA SILVEIRA KONIG;2024-09-20;2025-03-20;1;00005298008
02197384082;ISABELLA VILELA;2024-09-20;2025-03-20;1;02197384082
01198810041;JULIANO DA SILVIA KONIG;2024-09-20;2025-03-20;1;01198810041
00888946066;JULIANA PEDROSO JAVIMCZIK;2024-09-20;2025-03-20;1;00888946066
29044797832;ANDRE RYSEVAS BABBO;2024-09-20;2025-03-20;1;29044797832
29044797832;ANDRE RYSEVAS BABBO;2024-09-20;2025-03-20;1;29044797832
02197384082;ISABELLA VILELA;2024-09-20;2025-03-20;1;02197384082
01198810041;JULIANO DA SILVIA KONIG;2024-09-20;2025-03-20;1;01198810041
00888946066;JULIANA PEDROSO JAVIMCZIK;2024-09-20;2025-03-20;1;00888946066
29044797832;ANDRE RYSEVAS BABBO;2024-09-20;2025-03-20;1;29044797832
29044797832;ANDRE RYSEVAS BABBO;2024-09-20;2025-03-20;1;29044797832
29044797832;ANDRE RYSEVAS BABBO;2024-09-20;2025-03-20;1;29044797832
26435681848;ITALO DIMARZIO;2024-09-20;2025-03-20;1;26435681848
05107842089;ANDRIELLY DE AVILA SILVEIRA;2024-09-20;2025-03-20;1;05107842089
86059092004;HAMID PUREZA;2024-09-20;2025-03-20;1;86059092004
86088777087;ANA VICTORIA DAVILA CAMARGO;2024-09-20;2025-03-20;1;86088777087
03545001040;LEONARDO SANTOS DA SILVA;2024-09-20;2025-03-20;1;03545001040
00428687008;KIM SAMUEL TAVARES;2024-09-20;2025-03-20;1;00428687008
03379443000;WAGNER LUIZ NUNES PADILHA;2024-09-20;2025-03-20;1;03379443000
02669395031;ANDRESSA GRASIELI BRAGA DOS SANTOS;2024-09-20;2025-03-20;1;02669395031
07904395495;REBECA BLEHM;2024-09-20;2025-03-20;1;07904395495
86463110078;MICAELLA DE BOER;2024-09-20;2025-03-20;1;86463110078
86320455020;VITORIA LUCHINI LAMM;2024-09-20;2025-03-20;1;86320455020
02832630081;GABRIEL HENZE BREGONZI;2024-09-20;2025-03-20;1;02832630081
02119074054;VANESSA DURANTI DA SILVA;2024-09-20;2025-03-20;1;02119074054
01603372083;CHRISTOPHER MACEDO LUIZ;2024-09-20;2025-03-20;1;01603372083
97360309034;DANIEL MOREIRA COELHO;2024-09-20;2025-03-20;1;97360309034
86842277000;ANDRIELLE FISCHER;2024-09-20;2025-03-20;1;86842277000
01010327062;ISABELLA NOSCHANG MITTELSTAEDT;2024-09-20;2025-03-20;1;01010327062
00954927044;NATHALIA NOSCHANG MITTELSTAEDT;2024-09-20;2025-03-20;1;00954927044
48335312087;ANA BEATRIZ NOSCHANG MITTELSTAEDT;2024-09-20;2025-03-20;1;48335312087
01336368012;MARCELA DIAS;2024-09-20;2025-03-20;1;01336368012
02221404025;GIULIA CARINA KRONBAUER RAICHLE;2024-09-20;2025-03-20;1;02221404025
71008390097;INGLIA LOPES;2024-09-20;2025-03-20;1;71008390097
00382173090;FABIANA NETTO RIBEIRO;2024-09-20;2025-03-20;1;00382173090
04502757012;LUISA BURTET MARTINS;2024-09-20;2025-03-20;1;04502757012
68402082068;DELCA BURTET MARTINS;2024-09-20;2025-03-20;1;68402082068
89888790072;FERNANDA MEDEIROS LOPES;2024-09-20;2025-03-20;1;89888790072
00005298008;ALINE RIBEIRO DA SILVEIRA KONIG;2024-09-20;2025-03-20;1;00005298008
02197384082;ISABELLA VILELA;2024-09-20;2025-03-20;1;02197384082
01198810041;JULIANO DA SILVIA KONIG;2024-09-20;2025-03-20;1;01198810041
00888946066;JULIANA PEDROSO JAVIMCZIK;2024-09-20;2025-03-20;1;00888946066
29044797832;ANDRE RYSEVAS BABBO;2024-09-20;2025-03-20;1;29044797832
29044797832;ANDRE RYSEVAS BABBO;2024-09-20;2025-03-20;1;29044797832
02197384082;ISABELLA VILELA;2024-09-20;2025-03-20;1;02197384082
01198810041;JULIANO DA SILVIA KONIG;2024-09-20;2025-03-20;1;01198810041
00888946066;JULIANA PEDROSO JAVIMCZIK;2024-09-20;2025-03-20;1;00888946066
29044797832;ANDRE RYSEVAS BABBO;2024-09-20;2025-03-20;1;29044797832
29044797832;ANDRE RYSEVAS BABBO;2024-09-20;2025-03-20;1;29044797832`; // Obter o texto da variável label
   }

   document.addEventListener("DOMContentLoaded", () => {
    /*labelsValue();
    percorrer();*/
    // percorre();
    ajuste();
   });

   function percorrer() {
    const listas = document.querySelector("#listas");
    const viewListas = document.querySelector("#viewListas");
    viewListas.innerHTML = ``;

    // Obter o conteúdo do elemento <label>
    const label = document.getElementById("listasText").value;
    // Expressão regular para encontrar CPFs (sequências de 11 dígitos)
    const regexCPF = /\b\d{11}\b/g;

    // Extrair CPFs do texto
    const cpfs = label.match(regexCPF);

    // Criar um mapa para contar as ocorrências
    const cpfCounts = cpfs.reduce((acc, cpf) => {
     acc[cpf] = (acc[cpf] || 0) + 1;
     return acc;
    }, {});

    // Separar os CPFs repetidos (mais de 2 ocorrências)
    const repeatedCPFs = Object.keys(cpfCounts).filter(cpf => cpfCounts[cpf] > 2);

    // Dividir o texto original em registros com base em quebras (supondo registros separados por espaço ou quebra de linha)
    const registros = label.split(/(?<=\d{11})\s+/);

    // Identificar os registros completos que contêm CPFs repetidos
    const registrosRepetidos = registros.filter(registro => repeatedCPFs.some(cpf => registro.includes(cpf)));

    // Verificar se há CPFs repetidos
    if (repeatedCPFs.length === 0) {
     console.log("Nenhum CPF repetido encontrado.");
    }

    //console.log(repeatedCPFs);

    // Exibir a quantidade de vezes que cada CPF repetido foi encontrado
    repeatedCPFs.forEach(cpf => {
     // Filtrar os registros para o CPF atual
     const registrosDoCpf = registrosRepetidos.filter(registro => registro.includes(cpf));
     console.log(`O CPF ${cpf} foi encontrado em ${cpfCounts[cpf] / 2} registros.`);

     // const p = document.createElement("span");
     const p = document.createElement("div");
     p.classList.add("el");
     p.innerHTML = `
      <p class="">
      O CPF ${cpf} foi encontrado em ${cpfCounts[cpf] / 2} registros.
      </p>
      <p class="">
      CPF: <br/> ${cpf}
      </p>
      <p class="">
      Registros completos:
      </p>
      <ul class="ul">
        ${registrosDoCpf.map(registro => `<li style="margin: 6px;">${registro}</li>`).join("")}
      </ul>
    `;
     viewListas.appendChild(p);
    });

    // Adicionar um <span> contendo todos os CPFs repetidos
    const spanCPFsRepetidos = document.createElement("div");

    spanCPFsRepetidos.classList.add("cpf-repetidos");
    spanCPFsRepetidos.classList.add("el");
    spanCPFsRepetidos.innerHTML = `
    <h3>CPFs Repetidos:</h3>
    <ul>
      ${repeatedCPFs.map(cpf => `<li>${cpf}</li>`).join("")}
    </ul>
  `;
    viewListas.prepend(spanCPFsRepetidos);
   }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/eruda" onload="eruda.init()"></script>
 </body>
</html>
